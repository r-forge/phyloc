fusco.test <- function(phy, rich = NULL, data = NULL, names = NULL, simulate=TRUE, sim.reps=1000, sim.CI = 0.95){        phy <- reorder(phy, "pruningwise")    if(! is.null(rich)){        # need to match richness to tips from the data.frame...        tipsAsSpecies <- FALSE    } else {        rich <- rep(1, length(phy$tip.label))        tipsAsSpecies <- TRUE    }    observed <- fusco.calc(phy, rich)    obsStats <- with(observed, c(median(I), IQR(I)/2))        ret <- list(observed=observed, median=median(observed$I), qd=IQR(observed$I)/2, tipsAsSpecies=tipsAsSpecies,                 nInformative=dim(observed)[1], nSpecies=sum(rich), nTips=length(rich))                    class(ret) <- "fusco"    if(simulate){        ret <- fusco.simulate(ret,  sim.reps, sim.CI)    }        return(ret)}fusco.calc <- function(phy, rich){    # OLD TO NEW CONVERTED    # rewritten by David Orme to use less expensive tree traversal    # assumes that fusco.test provides a vector of richnesses in the same tip order    # and that the tree is in pruningwise order        intNodes <- unique(phy$edge[,1])    nTip <- length(phy$tip.label)    nNode <- phy$Nnode    rich <- c(rich, rep(NA, nNode))        # Data store    tab <- data.frame(polytomy=logical(nNode), N1 = numeric(nNode),                      N2 = numeric(nNode), row.names=intNodes)        # loop tips    for(ind in seq(along=intNodes)){                # grab the daughters of the node        daughters <- phy$edge[,2][phy$edge[,1] == intNodes[ind]]        richD <- rich[daughters]                if(length(daughters) > 2){            tab$polytomy[ind] <- TRUE          } else {            tab[ind, 2:3] <- richD        }                rich[intNodes[ind]] <- sum(richD)    }        tab$S <- with(tab, N1 + N2)    tab <- subset(tab, ! polytomy & S > 3, select=-polytomy)        tab$B <- with(tab, pmax(N1, N2))    tab$M <- tab$S - 1    tab$m <- ceiling(tab$S/2)        tab$I <- with(tab, (B - m)/(M - m))    tab$S.odd <- (tab$S %% 2) == 1    tab$w <- with(tab, ifelse(S.odd, 1, ifelse(I > 0, M/S, 2*M/S)))     tab$I.w <- with(tab, (I*w)/mean(w))    tab$I.prime <- with(tab, ifelse(S.odd, I, I * M/S))    return(tab)}  fusco.simulate <- function(obj,  sim.reps=1000, sim.CI = 0.95){            # Think about which version of I to use    expFun <- function(nTips, nSpp){        nullTree <- fusco.null.tree(nTips, nSpp)        fuscoDist <- with(nullTree, fusco.calc(phy, rich))        return(c(median(fuscoDist$I), IQR(fuscoDist$I)/2))    }        simulated <- with(obj, replicate(sim.reps, expFun(nInformative + 1, nSpecies)))    simulated <- as.data.frame(t(simulated))    names(simulated) <- c("median", "qd")    sim.twotail <- c(1 - (1 - sim.CI)/2, (1 - sim.CI)/2)    sim.median <- quantile(simulated$median, sim.twotail)    sim.qd <- quantile(simulated$qd, sim.CI)        ret <- c(obj, list(simulated=simulated, sim.median=sim.median, sim.qd=sim.qd, sim.reps=sim.reps, sim.CI=sim.CI))    class(ret) <- "fusco"        return(ret)}fusco.null.tree <- function(nTips, nSpecies=NULL){    # think about this - doesn't guarantee the number    # of informative nodes...        if(nSpecies < nTips){        stop("Fewer species specified than internal nodes + 1")    }    phy <- rtree(nTips)        if(is.null(nSpecies)){        rich <- rep(1, nTips)    } else {        breaks <- sample(1:(nSpecies-1), nTips-1)        rich <- diff(c(0,breaks,nSpecies))    }        return(list(phy=phy, rich=rich))    }summary.fusco <- function(obj, ...){    print(obj)        cat("Weighted t test")    }print.fusco <- function(obj, ...){    cat("Fusco test for phylogenetic imbalance\n\n")        cat("  Tree with", obj$nInformative, "informative nodes and", obj$nTips, "tips.\n")    if(obj$tipsAsSpecies){        cat("  Tips are treated as species.\n\n")    } else {        cat("  Tips are higher taxa containing", obj$nSpecies, "species.\n")    }        if(! is.null(obj$simulated)){        cat(" ", sprintf("%2.1f%%", obj$sim.CI*100), "confidence intervals simulated using", obj$sim.reps, "replicates.\n" )    }    cat("\n")        cat("  Median I:", round(obj$median,3))    if(! is.null(obj$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  obj$sim.median[1],obj$sim.median[1]))    }    cat("\n")    cat("  Quartile deviation in I:", round(obj$qd,3))    if(! is.null(obj$simulated)){        cat(sprintf(" [%1.3f,%1.3f]",  obj$sim.qd[1],obj$sim.qd[1]))    }    cat("\n")   }plot.fusco <- function(x, smooth.correction=TRUE, breaks=10, ...){        fuscoDist <- hist(x$observed$I,breaks=breaks, plot=FALSE)        if(smooth.correction==TRUE){        # not yet implemented            }        abline(v=quantile(x$expected["median", ], CI.quant), col="red")    plot(fuscoDist, main="", xlab="Imbalance score")    abline(v=median(x$observed$I))}